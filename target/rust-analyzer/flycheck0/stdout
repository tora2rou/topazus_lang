{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: expected expression, found `,`\n  --> src/parser.rs:28:27\n   |\n28 |             Token::Add => ,\n   |                        -- ^ expected expression\n   |                        |\n   |                        while parsing the `match` arm starting here\n\n","$message_type":"diagnostic","children":[],"level":"error","message":"expected expression, found `,`","spans":[{"byte_end":621,"byte_start":620,"column_end":28,"column_start":27,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":"expected expression","line_end":28,"line_start":28,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":28,"highlight_start":27,"text":"            Token::Add => ,"}]},{"byte_end":619,"byte_start":617,"column_end":26,"column_start":24,"expansion":null,"file_name":"src/parser.rs","is_primary":false,"label":"while parsing the `match` arm starting here","line_end":28,"line_start":28,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":26,"highlight_start":24,"text":"            Token::Add => ,"}]}],"code":null}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"error: expected expression, found `,`\n  --> src/parser.rs:28:27\n   |\n28 |             Token::Add => ,\n   |                        -- ^ expected expression\n   |                        |\n   |                        while parsing the `match` arm starting here\n\n","$message_type":"diagnostic","children":[],"level":"error","message":"expected expression, found `,`","spans":[{"byte_end":621,"byte_start":620,"column_end":28,"column_start":27,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":"expected expression","line_end":28,"line_start":28,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":28,"highlight_start":27,"text":"            Token::Add => ,"}]},{"byte_end":619,"byte_start":617,"column_end":26,"column_start":24,"expansion":null,"file_name":"src/parser.rs","is_primary":false,"label":"while parsing the `match` arm starting here","line_end":28,"line_start":28,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":26,"highlight_start":24,"text":"            Token::Add => ,"}]}],"code":null}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"warning: unnecessary parentheses around `let` scrutinee expression\n  --> src/parser.rs:42:42\n   |\n42 |     if let (Some(Token::Lparentheses)) = (tokens.next()) {\n   |                                          ^             ^\n   |\n   = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default\nhelp: remove these parentheses\n   |\n42 -     if let (Some(Token::Lparentheses)) = (tokens.next()) {\n42 +     if let (Some(Token::Lparentheses)) = tokens.next()  {\n   |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"`#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"remove these parentheses","rendered":null,"spans":[{"byte_end":958,"byte_start":957,"column_end":43,"column_start":42,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":43,"highlight_start":42,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]},{"byte_end":972,"byte_start":971,"column_end":57,"column_start":56,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":57,"highlight_start":56,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]}]}],"level":"warning","message":"unnecessary parentheses around `let` scrutinee expression","spans":[{"byte_end":958,"byte_start":957,"column_end":43,"column_start":42,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":42,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]},{"byte_end":972,"byte_start":971,"column_end":57,"column_start":56,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":57,"highlight_start":56,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]}],"code":{"code":"unused_parens","explanation":null}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"warning: unnecessary parentheses around pattern\n  --> src/parser.rs:42:12\n   |\n42 |     if let (Some(Token::Lparentheses)) = (tokens.next()) {\n   |            ^                         ^\n   |\nhelp: remove these parentheses\n   |\n42 -     if let (Some(Token::Lparentheses)) = (tokens.next()) {\n42 +     if let Some(Token::Lparentheses)  = (tokens.next()) {\n   |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove these parentheses","rendered":null,"spans":[{"byte_end":928,"byte_start":927,"column_end":13,"column_start":12,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":13,"highlight_start":12,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]},{"byte_end":954,"byte_start":953,"column_end":39,"column_start":38,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":39,"highlight_start":38,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]}]}],"level":"warning","message":"unnecessary parentheses around pattern","spans":[{"byte_end":928,"byte_start":927,"column_end":13,"column_start":12,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":12,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]},{"byte_end":954,"byte_start":953,"column_end":39,"column_start":38,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":39,"highlight_start":38,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]}],"code":{"code":"unused_parens","explanation":null}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"warning: unnecessary parentheses around `let` scrutinee expression\n  --> src/parser.rs:42:42\n   |\n42 |     if let (Some(Token::Lparentheses)) = (tokens.next()) {\n   |                                          ^             ^\n   |\n   = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default\nhelp: remove these parentheses\n   |\n42 -     if let (Some(Token::Lparentheses)) = (tokens.next()) {\n42 +     if let (Some(Token::Lparentheses)) = tokens.next()  {\n   |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"`#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default","rendered":null,"spans":[]},{"children":[],"code":null,"level":"help","message":"remove these parentheses","rendered":null,"spans":[{"byte_end":958,"byte_start":957,"column_end":43,"column_start":42,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":43,"highlight_start":42,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]},{"byte_end":972,"byte_start":971,"column_end":57,"column_start":56,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":57,"highlight_start":56,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]}]}],"level":"warning","message":"unnecessary parentheses around `let` scrutinee expression","spans":[{"byte_end":958,"byte_start":957,"column_end":43,"column_start":42,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":43,"highlight_start":42,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]},{"byte_end":972,"byte_start":971,"column_end":57,"column_start":56,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":57,"highlight_start":56,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]}],"code":{"code":"unused_parens","explanation":null}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"warning: unnecessary parentheses around `match` scrutinee expression\n  --> src/parser.rs:49:14\n   |\n49 |         match(next){\n   |              ^    ^\n   |\nhelp: remove these parentheses\n   |\n49 -         match(next){\n49 +         match next {\n   |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove these parentheses","rendered":null,"spans":[{"byte_end":1121,"byte_start":1120,"column_end":15,"column_start":14,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":49,"line_start":49,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":15,"highlight_start":14,"text":"        match(next){"}]},{"byte_end":1126,"byte_start":1125,"column_end":20,"column_start":19,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":49,"line_start":49,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":20,"highlight_start":19,"text":"        match(next){"}]}]}],"level":"warning","message":"unnecessary parentheses around `match` scrutinee expression","spans":[{"byte_end":1121,"byte_start":1120,"column_end":15,"column_start":14,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":49,"line_start":49,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":15,"highlight_start":14,"text":"        match(next){"}]},{"byte_end":1126,"byte_start":1125,"column_end":20,"column_start":19,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":49,"line_start":49,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":20,"highlight_start":19,"text":"        match(next){"}]}],"code":{"code":"unused_parens","explanation":null}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"warning: unnecessary parentheses around pattern\n  --> src/parser.rs:42:12\n   |\n42 |     if let (Some(Token::Lparentheses)) = (tokens.next()) {\n   |            ^                         ^\n   |\nhelp: remove these parentheses\n   |\n42 -     if let (Some(Token::Lparentheses)) = (tokens.next()) {\n42 +     if let Some(Token::Lparentheses)  = (tokens.next()) {\n   |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove these parentheses","rendered":null,"spans":[{"byte_end":928,"byte_start":927,"column_end":13,"column_start":12,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":13,"highlight_start":12,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]},{"byte_end":954,"byte_start":953,"column_end":39,"column_start":38,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":39,"highlight_start":38,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]}]}],"level":"warning","message":"unnecessary parentheses around pattern","spans":[{"byte_end":928,"byte_start":927,"column_end":13,"column_start":12,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":13,"highlight_start":12,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]},{"byte_end":954,"byte_start":953,"column_end":39,"column_start":38,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":42,"line_start":42,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":39,"highlight_start":38,"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {"}]}],"code":{"code":"unused_parens","explanation":null}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"warning: unnecessary parentheses around `match` scrutinee expression\n  --> src/parser.rs:49:14\n   |\n49 |         match(next){\n   |              ^    ^\n   |\nhelp: remove these parentheses\n   |\n49 -         match(next){\n49 +         match next {\n   |\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"remove these parentheses","rendered":null,"spans":[{"byte_end":1121,"byte_start":1120,"column_end":15,"column_start":14,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":49,"line_start":49,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":15,"highlight_start":14,"text":"        match(next){"}]},{"byte_end":1126,"byte_start":1125,"column_end":20,"column_start":19,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":49,"line_start":49,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","text":[{"highlight_end":20,"highlight_start":19,"text":"        match(next){"}]}]}],"level":"warning","message":"unnecessary parentheses around `match` scrutinee expression","spans":[{"byte_end":1121,"byte_start":1120,"column_end":15,"column_start":14,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":49,"line_start":49,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":15,"highlight_start":14,"text":"        match(next){"}]},{"byte_end":1126,"byte_start":1125,"column_end":20,"column_start":19,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":49,"line_start":49,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":20,"highlight_start":19,"text":"        match(next){"}]}],"code":{"code":"unused_parens","explanation":null}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"error[E0308]: mismatched types\n  --> src/parser.rs:26:32\n   |\n26 |             Token::Int(num) => Literal::Int(num),\n   |                                ^^^^^^^^^^^^^^^^^ expected `Box<dyn Expression>`, found `Literal`\n   |\n   = note: expected struct `Box<(dyn Expression + 'static)>`\n                found enum `Literal`\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"expected struct `Box<(dyn Expression + 'static)>`\n     found enum `Literal`","rendered":null,"spans":[]}],"level":"error","message":"mismatched types","spans":[{"byte_end":542,"byte_start":525,"column_end":49,"column_start":32,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":"expected `Box<dyn Expression>`, found `Literal`","line_end":26,"line_start":26,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":49,"highlight_start":32,"text":"            Token::Int(num) => Literal::Int(num),"}]}],"code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"error[E0308]: mismatched types\n  --> src/parser.rs:26:32\n   |\n26 |             Token::Int(num) => Literal::Int(num),\n   |                                ^^^^^^^^^^^^^^^^^ expected `Box<dyn Expression>`, found `Literal`\n   |\n   = note: expected struct `Box<(dyn Expression + 'static)>`\n                found enum `Literal`\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"expected struct `Box<(dyn Expression + 'static)>`\n     found enum `Literal`","rendered":null,"spans":[]}],"level":"error","message":"mismatched types","spans":[{"byte_end":542,"byte_start":525,"column_end":49,"column_start":32,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":"expected `Box<dyn Expression>`, found `Literal`","line_end":26,"line_start":26,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":49,"highlight_start":32,"text":"            Token::Int(num) => Literal::Int(num),"}]}],"code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n  --> src/parser.rs:47:6\n   |\n39 | pub fn parse(input:Vec<Token>){\n   | ------------------------------ this function should return `Result` or `Option` to accept `?`\n...\n47 |     }?;\n   |      ^ cannot use the `?` operator in a function that returns `()`\n   |\nhelp: consider adding return type\n   |\n39 | pub fn parse(input:Vec<Token>) -> Result<(), Box<dyn std::error::Error>>{\n   |                                +++++++++++++++++++++++++++++++++++++++++\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"consider adding return type","rendered":null,"spans":[{"byte_end":860,"byte_start":860,"column_end":31,"column_start":31,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":39,"line_start":39,"suggested_replacement":" -> Result<(), Box<dyn std::error::Error>>","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":31,"highlight_start":31,"text":"pub fn parse(input:Vec<Token>){"}]}]}],"level":"error","message":"the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)","spans":[{"byte_end":1066,"byte_start":1065,"column_end":7,"column_start":6,"expansion":{"def_site_span":{"byte_end":0,"byte_start":0,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/main.rs","is_primary":false,"label":null,"line_end":1,"line_start":1,"suggested_replacement":null,"suggestion_applicability":null,"text":[]},"macro_decl_name":"desugaring of operator `?`","span":{"byte_end":1066,"byte_start":1065,"column_end":7,"column_start":6,"expansion":null,"file_name":"src/parser.rs","is_primary":false,"label":null,"line_end":47,"line_start":47,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":7,"highlight_start":6,"text":"    }?;"}]}},"file_name":"src/parser.rs","is_primary":true,"label":"cannot use the `?` operator in a function that returns `()`","line_end":47,"line_start":47,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":7,"highlight_start":6,"text":"    }?;"}]},{"byte_end":860,"byte_start":830,"column_end":31,"column_start":1,"expansion":null,"file_name":"src/parser.rs","is_primary":false,"label":"this function should return `Result` or `Option` to accept `?`","line_end":39,"line_start":39,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":31,"highlight_start":1,"text":"pub fn parse(input:Vec<Token>){"}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\n  --> src/parser.rs:47:6\n   |\n39 | pub fn parse(input:Vec<Token>){\n   | ------------------------------ this function should return `Result` or `Option` to accept `?`\n...\n47 |     }?;\n   |      ^ cannot use the `?` operator in a function that returns `()`\n   |\nhelp: consider adding return type\n   |\n39 | pub fn parse(input:Vec<Token>) -> Result<(), Box<dyn std::error::Error>>{\n   |                                +++++++++++++++++++++++++++++++++++++++++\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"help","message":"consider adding return type","rendered":null,"spans":[{"byte_end":860,"byte_start":860,"column_end":31,"column_start":31,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":null,"line_end":39,"line_start":39,"suggested_replacement":" -> Result<(), Box<dyn std::error::Error>>","suggestion_applicability":"MaybeIncorrect","text":[{"highlight_end":31,"highlight_start":31,"text":"pub fn parse(input:Vec<Token>){"}]}]}],"level":"error","message":"the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)","spans":[{"byte_end":1066,"byte_start":1065,"column_end":7,"column_start":6,"expansion":{"def_site_span":{"byte_end":0,"byte_start":0,"column_end":1,"column_start":1,"expansion":null,"file_name":"src/main.rs","is_primary":false,"label":null,"line_end":1,"line_start":1,"suggested_replacement":null,"suggestion_applicability":null,"text":[]},"macro_decl_name":"desugaring of operator `?`","span":{"byte_end":1066,"byte_start":1065,"column_end":7,"column_start":6,"expansion":null,"file_name":"src/parser.rs","is_primary":false,"label":null,"line_end":47,"line_start":47,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":7,"highlight_start":6,"text":"    }?;"}]}},"file_name":"src/parser.rs","is_primary":true,"label":"cannot use the `?` operator in a function that returns `()`","line_end":47,"line_start":47,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":7,"highlight_start":6,"text":"    }?;"}]},{"byte_end":860,"byte_start":830,"column_end":31,"column_start":1,"expansion":null,"file_name":"src/parser.rs","is_primary":false,"label":"this function should return `Result` or `Option` to accept `?`","line_end":39,"line_start":39,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":31,"highlight_start":1,"text":"pub fn parse(input:Vec<Token>){"}]}],"code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"error[E0308]: `match` arms have incompatible types\n  --> src/parser.rs:67:34\n   |\n49 |           match(next){\n   |           ----------- `match` arms have incompatible types\n50 |               Token::Ident(any) => if any == \"let\"{\n   |  __________________________________-\n51 | |                 //(let [type] name <- data)\n52 | |                 // (let [fn] name <- [type] [type var] -> | process |)\n53 | |                 tokens.next();\n...  |\n66 | |             },\n   | |_____________- this is found to be of type `()`\n67 |               Token::Ident(any) => None,\n   |                                    ^^^^ expected `()`, found `Option<_>`\n   |\n   = note: expected unit type `()`\n                   found enum `Option<_>`\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"expected unit type `()`\n        found enum `Option<_>`","rendered":null,"spans":[]}],"level":"error","message":"`match` arms have incompatible types","spans":[{"byte_end":1885,"byte_start":1881,"column_end":38,"column_start":34,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":"expected `()`, found `Option<_>`","line_end":67,"line_start":67,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":38,"highlight_start":34,"text":"            Token::Ident(any) => None,"}]},{"byte_end":1846,"byte_start":1161,"column_end":14,"column_start":34,"expansion":null,"file_name":"src/parser.rs","is_primary":false,"label":"this is found to be of type `()`","line_end":66,"line_start":50,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":50,"highlight_start":34,"text":"            Token::Ident(any) => if any == \"let\"{"},{"highlight_end":44,"highlight_start":1,"text":"                //(let [type] name <- data)"},{"highlight_end":71,"highlight_start":1,"text":"                // (let [fn] name <- [type] [type var] -> | process |)"},{"highlight_end":31,"highlight_start":1,"text":"                tokens.next();"},{"highlight_end":25,"highlight_start":1,"text":"                //[type]"},{"highlight_end":143,"highlight_start":1,"text":"                if let (Some(Token::Lbrackets),Some(Token::Ident(kind)),Some(Token::Rbrackets)) = (tokens.next(),tokens.next(),tokens.next()){"},{"highlight_end":30,"highlight_start":1,"text":"                    //name <-"},{"highlight_end":115,"highlight_start":1,"text":"                    if let(Some(Token::Ident(ident_name)),Some(Token::LeftArrow)) = (tokens.next(),tokens.next()){"},{"highlight_end":72,"highlight_start":1,"text":"                        if let Some(Token::Lbrackets) =  tokens.next(){"},{"highlight_end":1,"highlight_start":1,"text":""},{"highlight_end":26,"highlight_start":1,"text":"                        }"},{"highlight_end":30,"highlight_start":1,"text":"                        else{"},{"highlight_end":1,"highlight_start":1,"text":""},{"highlight_end":26,"highlight_start":1,"text":"                        }"},{"highlight_end":22,"highlight_start":1,"text":"                    }"},{"highlight_end":18,"highlight_start":1,"text":"                }"},{"highlight_end":14,"highlight_start":1,"text":"            },"}]},{"byte_end":1126,"byte_start":1115,"column_end":20,"column_start":9,"expansion":null,"file_name":"src/parser.rs","is_primary":false,"label":"`match` arms have incompatible types","line_end":49,"line_start":49,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":20,"highlight_start":9,"text":"        match(next){"}]}],"code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"error[E0308]: `match` arms have incompatible types\n  --> src/parser.rs:67:34\n   |\n49 |           match(next){\n   |           ----------- `match` arms have incompatible types\n50 |               Token::Ident(any) => if any == \"let\"{\n   |  __________________________________-\n51 | |                 //(let [type] name <- data)\n52 | |                 // (let [fn] name <- [type] [type var] -> | process |)\n53 | |                 tokens.next();\n...  |\n66 | |             },\n   | |_____________- this is found to be of type `()`\n67 |               Token::Ident(any) => None,\n   |                                    ^^^^ expected `()`, found `Option<_>`\n   |\n   = note: expected unit type `()`\n                   found enum `Option<_>`\n\n","$message_type":"diagnostic","children":[{"children":[],"code":null,"level":"note","message":"expected unit type `()`\n        found enum `Option<_>`","rendered":null,"spans":[]}],"level":"error","message":"`match` arms have incompatible types","spans":[{"byte_end":1885,"byte_start":1881,"column_end":38,"column_start":34,"expansion":null,"file_name":"src/parser.rs","is_primary":true,"label":"expected `()`, found `Option<_>`","line_end":67,"line_start":67,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":38,"highlight_start":34,"text":"            Token::Ident(any) => None,"}]},{"byte_end":1846,"byte_start":1161,"column_end":14,"column_start":34,"expansion":null,"file_name":"src/parser.rs","is_primary":false,"label":"this is found to be of type `()`","line_end":66,"line_start":50,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":50,"highlight_start":34,"text":"            Token::Ident(any) => if any == \"let\"{"},{"highlight_end":44,"highlight_start":1,"text":"                //(let [type] name <- data)"},{"highlight_end":71,"highlight_start":1,"text":"                // (let [fn] name <- [type] [type var] -> | process |)"},{"highlight_end":31,"highlight_start":1,"text":"                tokens.next();"},{"highlight_end":25,"highlight_start":1,"text":"                //[type]"},{"highlight_end":143,"highlight_start":1,"text":"                if let (Some(Token::Lbrackets),Some(Token::Ident(kind)),Some(Token::Rbrackets)) = (tokens.next(),tokens.next(),tokens.next()){"},{"highlight_end":30,"highlight_start":1,"text":"                    //name <-"},{"highlight_end":115,"highlight_start":1,"text":"                    if let(Some(Token::Ident(ident_name)),Some(Token::LeftArrow)) = (tokens.next(),tokens.next()){"},{"highlight_end":72,"highlight_start":1,"text":"                        if let Some(Token::Lbrackets) =  tokens.next(){"},{"highlight_end":1,"highlight_start":1,"text":""},{"highlight_end":26,"highlight_start":1,"text":"                        }"},{"highlight_end":30,"highlight_start":1,"text":"                        else{"},{"highlight_end":1,"highlight_start":1,"text":""},{"highlight_end":26,"highlight_start":1,"text":"                        }"},{"highlight_end":22,"highlight_start":1,"text":"                    }"},{"highlight_end":18,"highlight_start":1,"text":"                }"},{"highlight_end":14,"highlight_start":1,"text":"            },"}]},{"byte_end":1126,"byte_start":1115,"column_end":20,"column_start":9,"expansion":null,"file_name":"src/parser.rs","is_primary":false,"label":"`match` arms have incompatible types","line_end":49,"line_start":49,"suggested_replacement":null,"suggestion_applicability":null,"text":[{"highlight_end":20,"highlight_start":9,"text":"        match(next){"}]}],"code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"}}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"Some errors have detailed explanations: E0277, E0308.\n","$message_type":"diagnostic","children":[],"level":"failure-note","message":"Some errors have detailed explanations: E0277, E0308.","spans":[],"code":null}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"For more information about an error, try `rustc --explain E0277`.\n","$message_type":"diagnostic","children":[],"level":"failure-note","message":"For more information about an error, try `rustc --explain E0277`.","spans":[],"code":null}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"Some errors have detailed explanations: E0277, E0308.\n","$message_type":"diagnostic","children":[],"level":"failure-note","message":"Some errors have detailed explanations: E0277, E0308.","spans":[],"code":null}}
{"reason":"compiler-message","package_id":"path+file:///home/tora/original_lang#0.1.0","manifest_path":"/home/tora/original_lang/Cargo.toml","target":{"kind":["bin"],"crate_types":["bin"],"name":"original_lang","src_path":"/home/tora/original_lang/src/main.rs","edition":"2024","doc":true,"doctest":false,"test":true},"message":{"rendered":"For more information about an error, try `rustc --explain E0277`.\n","$message_type":"diagnostic","children":[],"level":"failure-note","message":"For more information about an error, try `rustc --explain E0277`.","spans":[],"code":null}}
{"reason":"build-finished","success":false}
