{"$message_type":"diagnostic","message":"expected expression, found `,`","code":null,"level":"error","spans":[{"file_name":"src/parser.rs","byte_start":620,"byte_end":621,"line_start":28,"line_end":28,"column_start":27,"column_end":28,"is_primary":true,"text":[{"text":"            Token::Add => ,","highlight_start":27,"highlight_end":28}],"label":"expected expression","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parser.rs","byte_start":617,"byte_end":619,"line_start":28,"line_end":28,"column_start":24,"column_end":26,"is_primary":false,"text":[{"text":"            Token::Add => ,","highlight_start":24,"highlight_end":26}],"label":"while parsing the `match` arm starting here","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: expected expression, found `,`\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:28:27\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m28\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Token::Add => ,\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m--\u001b[0m \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mexpected expression\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m                        \u001b[1m\u001b[94mwhile parsing the `match` arm starting here\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary parentheses around `let` scrutinee expression","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/parser.rs","byte_start":957,"byte_end":958,"line_start":42,"line_end":42,"column_start":42,"column_end":43,"is_primary":true,"text":[{"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {","highlight_start":42,"highlight_end":43}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parser.rs","byte_start":971,"byte_end":972,"line_start":42,"line_end":42,"column_start":56,"column_end":57,"is_primary":true,"text":[{"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {","highlight_start":56,"highlight_end":57}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/parser.rs","byte_start":957,"byte_end":958,"line_start":42,"line_end":42,"column_start":42,"column_end":43,"is_primary":true,"text":[{"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {","highlight_start":42,"highlight_end":43}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/parser.rs","byte_start":971,"byte_end":972,"line_start":42,"line_end":42,"column_start":56,"column_end":57,"is_primary":true,"text":[{"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {","highlight_start":56,"highlight_end":57}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary parentheses around `let` scrutinee expression\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:42:42\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     if let (Some(Token::Lparentheses)) = (tokens.next()) {\n   \u001b[1m\u001b[94m|\u001b[0m                                          \u001b[1m\u001b[33m^\u001b[0m             \u001b[1m\u001b[33m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default\n\u001b[1m\u001b[96mhelp\u001b[0m: remove these parentheses\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[91m- \u001b[0m    if let (Some(Token::Lparentheses)) = \u001b[91m(\u001b[0mtokens.next()\u001b[91m)\u001b[0m {\n\u001b[1m\u001b[94m42\u001b[0m \u001b[92m+ \u001b[0m    if let (Some(Token::Lparentheses)) = tokens.next()\u001b[92m \u001b[0m {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary parentheses around pattern","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/parser.rs","byte_start":927,"byte_end":928,"line_start":42,"line_end":42,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {","highlight_start":12,"highlight_end":13}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parser.rs","byte_start":953,"byte_end":954,"line_start":42,"line_end":42,"column_start":38,"column_end":39,"is_primary":true,"text":[{"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {","highlight_start":38,"highlight_end":39}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/parser.rs","byte_start":927,"byte_end":928,"line_start":42,"line_end":42,"column_start":12,"column_end":13,"is_primary":true,"text":[{"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {","highlight_start":12,"highlight_end":13}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/parser.rs","byte_start":953,"byte_end":954,"line_start":42,"line_end":42,"column_start":38,"column_end":39,"is_primary":true,"text":[{"text":"    if let (Some(Token::Lparentheses)) = (tokens.next()) {","highlight_start":38,"highlight_end":39}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary parentheses around pattern\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:42:12\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     if let (Some(Token::Lparentheses)) = (tokens.next()) {\n   \u001b[1m\u001b[94m|\u001b[0m            \u001b[1m\u001b[33m^\u001b[0m                         \u001b[1m\u001b[33m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove these parentheses\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m42\u001b[0m \u001b[91m- \u001b[0m    if let \u001b[91m(\u001b[0mSome(Token::Lparentheses)\u001b[91m)\u001b[0m = (tokens.next()) {\n\u001b[1m\u001b[94m42\u001b[0m \u001b[92m+ \u001b[0m    if let Some(Token::Lparentheses)\u001b[92m \u001b[0m = (tokens.next()) {\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"unnecessary parentheses around `match` scrutinee expression","code":{"code":"unused_parens","explanation":null},"level":"warning","spans":[{"file_name":"src/parser.rs","byte_start":1120,"byte_end":1121,"line_start":49,"line_end":49,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        match(next){","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parser.rs","byte_start":1125,"byte_end":1126,"line_start":49,"line_end":49,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        match(next){","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove these parentheses","code":null,"level":"help","spans":[{"file_name":"src/parser.rs","byte_start":1120,"byte_end":1121,"line_start":49,"line_end":49,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        match(next){","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null},{"file_name":"src/parser.rs","byte_start":1125,"byte_end":1126,"line_start":49,"line_end":49,"column_start":19,"column_end":20,"is_primary":true,"text":[{"text":"        match(next){","highlight_start":19,"highlight_end":20}],"label":null,"suggested_replacement":" ","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[33mwarning\u001b[0m\u001b[1m: unnecessary parentheses around `match` scrutinee expression\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:49:14\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m         match(next){\n   \u001b[1m\u001b[94m|\u001b[0m              \u001b[1m\u001b[33m^\u001b[0m    \u001b[1m\u001b[33m^\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: remove these parentheses\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[91m- \u001b[0m        match\u001b[91m(\u001b[0mnext\u001b[91m)\u001b[0m{\n\u001b[1m\u001b[94m49\u001b[0m \u001b[92m+ \u001b[0m        match\u001b[92m \u001b[0mnext\u001b[92m \u001b[0m{\n   \u001b[1m\u001b[94m|\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/parser.rs","byte_start":525,"byte_end":542,"line_start":26,"line_end":26,"column_start":32,"column_end":49,"is_primary":true,"text":[{"text":"            Token::Int(num) => Literal::Int(num),","highlight_start":32,"highlight_end":49}],"label":"expected `Box<dyn Expression>`, found `Literal`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected struct `Box<(dyn Expression + 'static)>`\n     found enum `Literal`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: mismatched types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:26:32\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m26\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             Token::Int(num) => Literal::Int(num),\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Box<dyn Expression>`, found `Literal`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected struct `\u001b[1m\u001b[35mBox<(dyn Expression + 'static)>\u001b[0m`\n                found enum `\u001b[1m\u001b[35mLiteral\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)","code":{"code":"E0277","explanation":"You tried to use a type which doesn't implement some trait in a place which\nexpected that trait.\n\nErroneous code example:\n\n```compile_fail,E0277\n// here we declare the Foo trait with a bar method\ntrait Foo {\n    fn bar(&self);\n}\n\n// we now declare a function which takes an object implementing the Foo trait\nfn some_func<T: Foo>(foo: T) {\n    foo.bar();\n}\n\nfn main() {\n    // we now call the method with the i32 type, which doesn't implement\n    // the Foo trait\n    some_func(5i32); // error: the trait bound `i32 : Foo` is not satisfied\n}\n```\n\nIn order to fix this error, verify that the type you're using does implement\nthe trait. Example:\n\n```\ntrait Foo {\n    fn bar(&self);\n}\n\n// we implement the trait on the i32 type\nimpl Foo for i32 {\n    fn bar(&self) {}\n}\n\nfn some_func<T: Foo>(foo: T) {\n    foo.bar(); // we can now use this method since i32 implements the\n               // Foo trait\n}\n\nfn main() {\n    some_func(5i32); // ok!\n}\n```\n\nOr in a generic context, an erroneous code example would look like:\n\n```compile_fail,E0277\nfn some_func<T>(foo: T) {\n    println!(\"{:?}\", foo); // error: the trait `core::fmt::Debug` is not\n                           //        implemented for the type `T`\n}\n\nfn main() {\n    // We now call the method with the i32 type,\n    // which *does* implement the Debug trait.\n    some_func(5i32);\n}\n```\n\nNote that the error here is in the definition of the generic function. Although\nwe only call it with a parameter that does implement `Debug`, the compiler\nstill rejects the function. It must work with all possible input types. In\norder to make this example compile, we need to restrict the generic type we're\naccepting:\n\n```\nuse std::fmt;\n\n// Restrict the input type to types that implement Debug.\nfn some_func<T: fmt::Debug>(foo: T) {\n    println!(\"{:?}\", foo);\n}\n\nfn main() {\n    // Calling the method is still fine, as i32 implements Debug.\n    some_func(5i32);\n\n    // This would fail to compile now:\n    // struct WithoutDebug;\n    // some_func(WithoutDebug);\n}\n```\n\nRust only looks at the signature of the called function, as such it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"src/parser.rs","byte_start":1065,"byte_end":1066,"line_start":47,"line_end":47,"column_start":6,"column_end":7,"is_primary":true,"text":[{"text":"    }?;","highlight_start":6,"highlight_end":7}],"label":"cannot use the `?` operator in a function that returns `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/parser.rs","byte_start":1065,"byte_end":1066,"line_start":47,"line_end":47,"column_start":6,"column_end":7,"is_primary":false,"text":[{"text":"    }?;","highlight_start":6,"highlight_end":7}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"desugaring of operator `?`","def_site_span":{"file_name":"src/main.rs","byte_start":0,"byte_end":0,"line_start":1,"line_end":1,"column_start":1,"column_end":1,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}},{"file_name":"src/parser.rs","byte_start":830,"byte_end":860,"line_start":39,"line_end":39,"column_start":1,"column_end":31,"is_primary":false,"text":[{"text":"pub fn parse(input:Vec<Token>){","highlight_start":1,"highlight_end":31}],"label":"this function should return `Result` or `Option` to accept `?`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"consider adding return type","code":null,"level":"help","spans":[{"file_name":"src/parser.rs","byte_start":860,"byte_end":860,"line_start":39,"line_end":39,"column_start":31,"column_end":31,"is_primary":true,"text":[{"text":"pub fn parse(input:Vec<Token>){","highlight_start":31,"highlight_end":31}],"label":null,"suggested_replacement":" -> Result<(), Box<dyn std::error::Error>>","suggestion_applicability":"MaybeIncorrect","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0277]\u001b[0m\u001b[1m: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `FromResidual`)\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:47:6\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m|\u001b[0m pub fn parse(input:Vec<Token>){\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m------------------------------\u001b[0m \u001b[1m\u001b[94mthis function should return `Result` or `Option` to accept `?`\u001b[0m\n\u001b[1m\u001b[94m...\u001b[0m\n\u001b[1m\u001b[94m47\u001b[0m \u001b[1m\u001b[94m|\u001b[0m     }?;\n   \u001b[1m\u001b[94m|\u001b[0m      \u001b[1m\u001b[91m^\u001b[0m \u001b[1m\u001b[91mcannot use the `?` operator in a function that returns `()`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: consider adding return type\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m39\u001b[0m \u001b[1m\u001b[94m| \u001b[0mpub fn parse(input:Vec<Token>)\u001b[92m -> Result<(), Box<dyn std::error::Error>>\u001b[0m{\n   \u001b[1m\u001b[94m|\u001b[0m                                \u001b[92m+++++++++++++++++++++++++++++++++++++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"src/parser.rs","byte_start":1881,"byte_end":1885,"line_start":67,"line_end":67,"column_start":34,"column_end":38,"is_primary":true,"text":[{"text":"            Token::Ident(any) => None,","highlight_start":34,"highlight_end":38}],"label":"expected `()`, found `Option<_>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parser.rs","byte_start":1161,"byte_end":1846,"line_start":50,"line_end":66,"column_start":34,"column_end":14,"is_primary":false,"text":[{"text":"            Token::Ident(any) => if any == \"let\"{","highlight_start":34,"highlight_end":50},{"text":"                //(let [type] name <- data)","highlight_start":1,"highlight_end":44},{"text":"                // (let [fn] name <- [type] [type var] -> | process |)","highlight_start":1,"highlight_end":71},{"text":"                tokens.next();","highlight_start":1,"highlight_end":31},{"text":"                //[type]","highlight_start":1,"highlight_end":25},{"text":"                if let (Some(Token::Lbrackets),Some(Token::Ident(kind)),Some(Token::Rbrackets)) = (tokens.next(),tokens.next(),tokens.next()){","highlight_start":1,"highlight_end":143},{"text":"                    //name <-","highlight_start":1,"highlight_end":30},{"text":"                    if let(Some(Token::Ident(ident_name)),Some(Token::LeftArrow)) = (tokens.next(),tokens.next()){","highlight_start":1,"highlight_end":115},{"text":"                        if let Some(Token::Lbrackets) =  tokens.next(){","highlight_start":1,"highlight_end":72},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                        else{","highlight_start":1,"highlight_end":30},{"text":"","highlight_start":1,"highlight_end":1},{"text":"                        }","highlight_start":1,"highlight_end":26},{"text":"                    }","highlight_start":1,"highlight_end":22},{"text":"                }","highlight_start":1,"highlight_end":18},{"text":"            },","highlight_start":1,"highlight_end":14}],"label":"this is found to be of type `()`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/parser.rs","byte_start":1115,"byte_end":1126,"line_start":49,"line_end":49,"column_start":9,"column_end":20,"is_primary":false,"text":[{"text":"        match(next){","highlight_start":9,"highlight_end":20}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected unit type `()`\n        found enum `Option<_>`","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m: `match` arms have incompatible types\u001b[0m\n  \u001b[1m\u001b[94m--> \u001b[0msrc/parser.rs:67:34\n   \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m49\u001b[0m \u001b[1m\u001b[94m|\u001b[0m           match(next){\n   \u001b[1m\u001b[94m|\u001b[0m           \u001b[1m\u001b[94m-----------\u001b[0m \u001b[1m\u001b[94m`match` arms have incompatible types\u001b[0m\n\u001b[1m\u001b[94m50\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               Token::Ident(any) => if any == \"let\"{\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m __________________________________-\u001b[0m\n\u001b[1m\u001b[94m51\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 //(let [type] name <- data)\n\u001b[1m\u001b[94m52\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 // (let [fn] name <- [type] [type var] -> | process |)\n\u001b[1m\u001b[94m53\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m                 tokens.next();\n\u001b[1m\u001b[94m...\u001b[0m  \u001b[1m\u001b[94m|\u001b[0m\n\u001b[1m\u001b[94m66\u001b[0m \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|\u001b[0m             },\n   \u001b[1m\u001b[94m|\u001b[0m \u001b[1m\u001b[94m|_____________-\u001b[0m \u001b[1m\u001b[94mthis is found to be of type `()`\u001b[0m\n\u001b[1m\u001b[94m67\u001b[0m \u001b[1m\u001b[94m|\u001b[0m               Token::Ident(any) => None,\n   \u001b[1m\u001b[94m|\u001b[0m                                    \u001b[1m\u001b[91m^^^^\u001b[0m \u001b[1m\u001b[91mexpected `()`, found `Option<_>`\u001b[0m\n   \u001b[1m\u001b[94m|\u001b[0m\n   \u001b[1m\u001b[94m= \u001b[0m\u001b[1mnote\u001b[0m: expected unit type `\u001b[1m\u001b[35m()\u001b[0m`\n                   found enum `\u001b[1m\u001b[35mOption<_>\u001b[0m`\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 4 previous errors; 3 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m: aborting due to 4 previous errors; 3 warnings emitted\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"Some errors have detailed explanations: E0277, E0308.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mSome errors have detailed explanations: E0277, E0308.\u001b[0m\n"}
{"$message_type":"diagnostic","message":"For more information about an error, try `rustc --explain E0277`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1mFor more information about an error, try `rustc --explain E0277`.\u001b[0m\n"}
